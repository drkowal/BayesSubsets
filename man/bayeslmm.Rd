% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/source_bayeslmm.R
\name{bayeslmm}
\alias{bayeslmm}
\title{Bayesian linear mixed models (LMMs)}
\usage{
bayeslmm(Y, X, nsave = 1000, nburn = 1000)
}
\arguments{
\item{Y}{(\code{m x n}) matrix of response variables}

\item{X}{(\code{n x p}) matrix of covariates}

\item{nsave}{number of MCMC iterations to record}

\item{nburn}{number of MCMC iterations to discard (burn-in)}
}
\value{
a list containing the following elements:
\itemize{
\item \code{coefficients} the estimated regression coefficients (posterior means)
\item \code{fitted.values} the fitted values (posterior means)
\item \code{post_y_pred} posterior predictive draws
\item \code{post_y_pred_sum} posterior predictive totals for each subject
\item \code{post_beta} posterior draws of the regression coefficients
\item \code{post_u} posterior draws of the random intercepts
\item \code{post_sigma_u} posterior draws of the random intercept standard deviation
\item \code{post_sigma_e} posterior draws of the observation error standard deviation
\item \code{post_lpd} posterior draws of the log-likelihood (i.e., the log-likelihood
evaluated at each posterior draw of the model parameters)
}
}
\description{
Efficient blocked Gibbs sampler for a Bayesian linear
regression model with random intercepts. The fixed effects
(regression coefficients) and the random effects (intercepts)
are sampled *jointly* for Monte Carlo efficiency, while the variance
components are sampled in a separate block. The model uses a
horseshoe prior for the fixed effects (regression coefficients).
}
\examples{
# Simulate some data:
dat = simulate_lm_randint(n = 100, # subjects
                          p = 15,  # covariates
                          m = 4)   # replicates per subject
Y = dat$Y; X = dat$X

# Dimensions:
dim(Y) # m x n
dim(X) # n x p

# Fit the model:
fit = bayeslmm(Y = Y, X = X) # should take a few seconds
names(fit) # what is returned

# Estimated coefficients:
coef(fit)

# Compare to ground truth:
plot(coef(fit), dat$beta_true,
     main = 'True and estimated coefficients',
     xlab = 'Estimated', ylab = 'True')
abline(0,1)

# 90\% credible intervals:
ci_beta = t(apply(fit$post_beta, 2,
                  quantile, c(0.05, 0.95)))

# Fitted values (m x n):
dim(fitted(fit))

# MCMC diagnostics:
plot(as.ts(fit$post_beta[,1:6]))

}
